// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// User entity - authentication and profile information
/// Security: Passwords MUST be bcrypt-hashed (10+ rounds)
/// Privacy: User emails/names are NOT anonymized in research exports
model User {
  /// Auto-incrementing user identifier
  id        Int      @id @default(autoincrement())
  
  /// User's display name (3-50 characters)
  name      String   @db.VarChar(100)
  
  /// Unique email address for authentication
  email     String   @unique @db.VarChar(255)
  
  /// Bcrypt-hashed password (NEVER stored as plain text)
  /// IMPORTANT: Bcrypt always produces 60-character hashes
  password  String   @db.Char(60)
  
  /// User creation timestamp
  createdAt DateTime @default(now()) @map("created_at")
  
  /// Last update timestamp
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relationships
  teamMembers    TeamMember[]
  invitesSent    TeamInvite[] @relation("invites_sent")
  invitesReceived TeamInvite[] @relation("invites_received")
  
  @@map("users")
}

/// Team entity - represents a research team using the platform
/// Isolation: team_id is the primary boundary for all queries
/// Privacy: Team names are not anonymized in research exports
model Team {
  /// Auto-incrementing team identifier
  id           Int            @id @default(autoincrement())
  
  /// Team name (3-100 characters, unique across platform)
  name         String         @unique @db.VarChar(100)
  
  /// Team creation timestamp
  createdAt    DateTime       @default(now()) @map("created_at")
  
  /// Last update timestamp
  updatedAt    DateTime       @updatedAt @map("updated_at")
  
  // Relationships
  teamMembers   TeamMember[]
  teamPractices TeamPractice[]
  teamInvites   TeamInvite[]
  
  @@index([name], map: "idx_teams_name")
  @@map("teams")
}

/// TeamMember entity - represents user membership in teams
/// Isolation: Queries must filter by both teamId and userId
model TeamMember {
  /// Auto-incrementing member identifier
  id       Int      @id @default(autoincrement())
  
  /// Team identifier
  teamId   Int      @map("team_id")
  
  /// User identifier
  userId   Int      @map("user_id")
  
  /// Member role (owner, member)
  role     String   @default("member") @db.VarChar(20)
  
  /// Membership creation timestamp
  joinedAt DateTime @default(now()) @map("joined_at")
  
  // Relationships
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@index([teamId], map: "idx_team_members_team")
  @@index([userId], map: "idx_team_members_user")
  @@map("team_members")
}

/// TeamInvite entity - pending or completed invitations to join a team
/// Isolation: Queries must filter by teamId
model TeamInvite {
  /// Auto-incrementing invite identifier
  id            Int      @id @default(autoincrement())

  /// Team identifier
  teamId        Int      @map("team_id")

  /// Email address of invitee
  email         String   @db.VarChar(255)

  /// Invite status (Pending, Added, Failed)
  status        String   @db.VarChar(20)

  /// User who sent the invite
  invitedBy     Int      @map("invited_by")

  /// Existing user invited (if any)
  invitedUserId Int?     @map("invited_user_id")

  /// Invite creation timestamp
  createdAt     DateTime @default(now()) @map("created_at")

  /// Invite update timestamp
  updatedAt     DateTime @updatedAt @map("updated_at")

  /// Last email sent timestamp
  lastSentAt    DateTime? @map("last_sent_at")

  /// Last email error message (if any)
  errorMessage  String?  @map("error_message") @db.Text

  // Relationships
  team          Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedByUser User     @relation("invites_sent", fields: [invitedBy], references: [id], onDelete: Cascade)
  invitedUser   User?    @relation("invites_received", fields: [invitedUserId], references: [id], onDelete: SetNull)

  @@unique([teamId, email], map: "uq_team_invites_team_email")
  @@index([teamId], map: "idx_team_invites_team")
  @@index([email], map: "idx_team_invites_email")
  @@map("team_invites")
}

/// Category entity - the 5 high-level categories from APR framework
/// Isolation: Categories are global reference data
model Category {
  /// Category identifier (VARCHAR, not auto-increment)
  id          String   @id @db.VarChar(50)
  
  /// Category name
  name        String   @unique @db.VarChar(255)
  
  /// Category description
  description String?  @db.Text
  
  /// Display order for UI presentation
  displayOrder Int    @map("display_order")
  
  /// Category creation timestamp
  createdAt   DateTime @default(now()) @map("created_at")
  
  /// Last update timestamp
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relationships
  pillars     Pillar[]
  practices   Practice[]
  
  @@map("categories")
}

/// Pillar entity - the 19 agile pillars from APR framework
/// Isolation: Pillars are global reference data
model Pillar {
  /// Auto-incrementing pillar identifier
  id          Int      @id @default(autoincrement())
  
  /// Pillar name (unique)
  name        String   @db.VarChar(255)
  
  /// Category this pillar belongs to
  categoryId  String   @map("category_id") @db.VarChar(50)
  
  /// Pillar description
  description String?  @db.Text
  
  /// Pillar creation timestamp
  createdAt   DateTime @default(now()) @map("created_at")
  
  /// Last update timestamp
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relationships
  category        Category         @relation(fields: [categoryId], references: [id])
  practicePillars PracticePillar[]
  
  @@unique([name, categoryId], map: "uq_pillars_name_category")
  @@index([categoryId], map: "idx_pillars_category")
  @@map("pillars")
}

/// Practice entity - agile practices catalog
/// Isolation: Practices are global (isGlobal=true) or team-specific
model Practice {
  /// Auto-incrementing practice identifier
  id                   Int       @id @default(autoincrement())
  
  /// Practice title (2-100 characters)
  title                String    @db.VarChar(100)
  
  /// Practice goal/objective (1-500 chars)
  goal                 String    @db.VarChar(500)
  
  /// Full practice description (optional, max 10,000 chars)
  description          String?   @db.Text
  
  /// Practice category (FK to categories)
  categoryId           String    @map("category_id") @db.VarChar(50)
  
  /// Framework/method (Scrum, XP, Kanban, etc.)
  method               String?   @db.VarChar(50)
  
  /// Behavioral tags (Visual/Tactile, Async-Ready, etc.)
  tags                 Json?
  
  /// Structured activities (sequence, name, description)
  activities           Json?
  
  /// Roles involved (role, responsibility/RACI)
  roles                Json?
  
  /// Work products/artifacts created
  workProducts         Json?     @map("work_products")
  
  /// Completion criteria / Definition of Done
  completionCriteria   String?   @map("completion_criteria") @db.Text
  
  /// Success metrics
  metrics              Json?
  
  /// Resource guidelines (links, guides)
  guidelines           Json?
  
  /// Common pitfalls to avoid
  pitfalls             Json?
  
  /// Practice benefits
  benefits             Json?
  
  /// Associated practices (relationships)
  associatedPractices  Json?     @map("associated_practices")
  
  /// Is this a global practice (available to all teams)
  isGlobal             Boolean   @default(true) @map("is_global")
  
  /// When practice was imported
  importedAt           DateTime? @map("imported_at")
  
  /// Source file name
  sourceFile           String?   @map("source_file") @db.VarChar(255)
  
  /// JSON checksum (SHA256) for idempotency
  jsonChecksum         String?   @map("json_checksum") @db.VarChar(64)
  
  /// Practice version number
  practiceVersion      Int       @default(1) @map("practice_version")
  
  /// Who imported this practice
  importedBy           String?   @map("imported_by") @db.VarChar(100)
  
  /// Git SHA of source at import time
  sourceGitSha         String?   @map("source_git_sha") @db.VarChar(40)
  
  /// Raw JSON for debugging and provenance
  rawJson              Json?     @map("raw_json")
  
  /// Practice creation timestamp
  createdAt            DateTime  @default(now()) @map("created_at")
  
  /// Last update timestamp
  updatedAt            DateTime  @updatedAt @map("updated_at")
  
  // Relationships
  category         Category         @relation(fields: [categoryId], references: [id])
  teamPractices    TeamPractice[]
  practicePillars  PracticePillar[]
  
  @@unique([title, categoryId], map: "uq_practices_title_category")
  @@index([categoryId], map: "idx_practices_category")
  @@index([title], map: "idx_practices_title")
  @@index([goal], map: "idx_practices_goal")
  @@index([isGlobal], map: "idx_practices_is_global")
  @@index([method], map: "idx_practices_method")
  @@map("practices")
}

/// TeamPractice entity - links teams to practices they use
/// Isolation: Queries must filter by teamId
model TeamPractice {
  /// Auto-incrementing identifier
  id         Int      @id @default(autoincrement())
  
  /// Team identifier
  teamId     Int      @map("team_id")
  
  /// Practice identifier
  practiceId Int      @map("practice_id")
  
  /// When practice was added to team
  addedAt    DateTime @default(now()) @map("added_at")
  
  // Relationships
  team       Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, practiceId])
  @@index([teamId], map: "idx_team_practices_team")
  @@index([practiceId], map: "idx_team_practices_practice")
  @@map("team_practices")
}

/// PracticePillar entity - maps practices to pillars they cover
/// Isolation: Used for coverage calculation
model PracticePillar {
  /// Practice identifier
  practiceId Int      @map("practice_id")
  
  /// Pillar identifier
  pillarId   Int      @map("pillar_id")
  
  /// When relationship was created
  createdAt  DateTime @default(now()) @map("created_at")
  
  // Relationships
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  pillar     Pillar   @relation(fields: [pillarId], references: [id], onDelete: Cascade)
  
  @@id([practiceId, pillarId])
  @@index([practiceId], map: "idx_practice_pillars_practice")
  @@index([pillarId], map: "idx_practice_pillars_pillar")
  @@index([practiceId, pillarId], map: "idx_practice_pillars_practice_pillar")
  @@map("practice_pillars")
}

/// Event entity - immutable audit log for research data integrity
/// Isolation: team_id is the primary boundary for all queries
/// Privacy: Events contain system actions, not sensitive user data
model Event {
  /// Auto-incrementing event identifier
  id            BigInt   @id @default(autoincrement())
  
  /// Event classification (e.g., 'user.registered', 'issue.created')
  eventType     String   @map("event_type") @db.VarChar(50)
  
  /// User who triggered the event (NULL for system events)
  actorId       Int?     @map("actor_id")
  
  /// Team context for the event (NULL for user-level events)
  teamId        Int?     @map("team_id")
  
  /// Type of entity affected (e.g., 'user', 'issue', 'practice')
  entityType    String?  @map("entity_type") @db.VarChar(50)
  
  /// Identifier of the affected entity
  entityId      Int?     @map("entity_id")
  
  /// Action performed (e.g., 'created', 'updated', 'deleted')
  action        String?  @db.VarChar(50)
  
  /// JSON payload with event-specific data
  payload       Json?
  
  /// Schema version for payload structure evolution
  schemaVersion String   @default("v1") @map("schema_version") @db.VarChar(10)
  
  /// Event creation timestamp (immutable)
  createdAt     DateTime @default(now()) @map("created_at")
  
  @@index([teamId, eventType], map: "idx_events_team_type")
  @@index([entityType, entityId], map: "idx_events_entity")
  @@index([eventType], map: "idx_events_type")
  @@map("events")
}
