// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// User entity - authentication and profile information
/// Security: Passwords MUST be bcrypt-hashed (10+ rounds)
/// Privacy: User emails/names are NOT anonymized in research exports
model User {
  /// Auto-incrementing user identifier
  id        Int      @id @default(autoincrement())
  
  /// User's display name (3-50 characters)
  name      String   @db.VarChar(100)
  
  /// Unique email address for authentication
  email     String   @unique @db.VarChar(255)
  
  /// Bcrypt-hashed password (NEVER stored as plain text)
  /// IMPORTANT: Bcrypt always produces 60-character hashes
  password  String   @db.Char(60)
  
  /// User creation timestamp
  createdAt DateTime @default(now()) @map("created_at")
  
  /// Last update timestamp
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relationships
  teamMembers    TeamMember[]
  invitesSent    TeamInvite[] @relation("invites_sent")
  invitesReceived TeamInvite[] @relation("invites_received")
  
  @@map("users")
}

/// Team entity - represents a research team using the platform
/// Isolation: team_id is the primary boundary for all queries
/// Privacy: Team names are not anonymized in research exports
model Team {
  /// Auto-incrementing team identifier
  id           Int            @id @default(autoincrement())
  
  /// Team name (3-100 characters, unique across platform)
  name         String         @unique @db.VarChar(100)
  
  /// Team creation timestamp
  createdAt    DateTime       @default(now()) @map("created_at")
  
  /// Last update timestamp
  updatedAt    DateTime       @updatedAt @map("updated_at")
  
  // Relationships
  teamMembers   TeamMember[]
  teamPractices TeamPractice[]
  teamInvites   TeamInvite[]
  
  @@index([name], map: "idx_teams_name")
  @@map("teams")
}

/// TeamMember entity - represents user membership in teams
/// Isolation: Queries must filter by both teamId and userId
model TeamMember {
  /// Auto-incrementing member identifier
  id       Int      @id @default(autoincrement())
  
  /// Team identifier
  teamId   Int      @map("team_id")
  
  /// User identifier
  userId   Int      @map("user_id")
  
  /// Member role (owner, member)
  role     String   @default("member") @db.VarChar(20)
  
  /// Membership creation timestamp
  joinedAt DateTime @default(now()) @map("joined_at")
  
  // Relationships
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@index([teamId], map: "idx_team_members_team")
  @@index([userId], map: "idx_team_members_user")
  @@map("team_members")
}

/// TeamInvite entity - pending or completed invitations to join a team
/// Isolation: Queries must filter by teamId
model TeamInvite {
  /// Auto-incrementing invite identifier
  id            Int      @id @default(autoincrement())

  /// Team identifier
  teamId        Int      @map("team_id")

  /// Email address of invitee
  email         String   @db.VarChar(255)

  /// Invite status (Pending, Added, Failed)
  status        String   @db.VarChar(20)

  /// User who sent the invite
  invitedBy     Int      @map("invited_by")

  /// Existing user invited (if any)
  invitedUserId Int?     @map("invited_user_id")

  /// Invite creation timestamp
  createdAt     DateTime @default(now()) @map("created_at")

  /// Invite update timestamp
  updatedAt     DateTime @updatedAt @map("updated_at")

  /// Last email sent timestamp
  lastSentAt    DateTime? @map("last_sent_at")

  /// Last email error message (if any)
  errorMessage  String?  @map("error_message") @db.Text

  // Relationships
  team          Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedByUser User     @relation("invites_sent", fields: [invitedBy], references: [id], onDelete: Cascade)
  invitedUser   User?    @relation("invites_received", fields: [invitedUserId], references: [id], onDelete: SetNull)

  @@unique([teamId, email], map: "uq_team_invites_team_email")
  @@index([teamId], map: "idx_team_invites_team")
  @@index([email], map: "idx_team_invites_email")
  @@map("team_invites")
}

/// Practice entity - agile practices catalog
/// Isolation: Practices are global (isGlobal=true) or team-specific
model Practice {
  /// Auto-incrementing practice identifier
  id          Int      @id @default(autoincrement())
  
  /// Practice title (3-100 characters)
  title       String   @db.VarChar(100)
  
  /// Practice goal/description
  goal        String   @db.Text
  
  /// Practice category
  category    String   @db.VarChar(50)
  
  /// Is this a global practice (available to all teams)
  isGlobal    Boolean  @default(true) @map("is_global")
  
  /// Practice creation timestamp
  createdAt   DateTime @default(now()) @map("created_at")
  
  // Relationships
  teamPractices TeamPractice[]
  practicePillars PracticePillar[]
  
  @@index([category], map: "idx_practices_category")
  @@map("practices")
}

/// TeamPractice entity - links teams to practices they use
/// Isolation: Queries must filter by teamId
model TeamPractice {
  /// Auto-incrementing identifier
  id         Int      @id @default(autoincrement())
  
  /// Team identifier
  teamId     Int      @map("team_id")
  
  /// Practice identifier
  practiceId Int      @map("practice_id")
  
  /// When practice was added to team
  addedAt    DateTime @default(now()) @map("added_at")
  
  // Relationships
  team       Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, practiceId])
  @@index([teamId], map: "idx_team_practices_team")
  @@index([practiceId], map: "idx_team_practices_practice")
  @@map("team_practices")
}

/// Pillar entity - the 19 agile pillars from APR framework
/// Isolation: Pillars are global reference data
model Pillar {
  /// Auto-incrementing pillar identifier
  id       Int      @id @default(autoincrement())
  
  /// Pillar name (unique)
  name     String   @unique @db.VarChar(100)
  
  /// Pillar category (e.g., 'Team Structure', 'Development Process')
  category String   @db.VarChar(50)
  
  // Relationships
  practicePillars PracticePillar[]
  
  @@map("pillars")
}

/// PracticePillar entity - maps practices to pillars they cover
/// Isolation: Used for coverage calculation
model PracticePillar {
  /// Auto-incrementing identifier
  id         Int      @id @default(autoincrement())
  
  /// Practice identifier
  practiceId Int      @map("practice_id")
  
  /// Pillar identifier
  pillarId   Int      @map("pillar_id")
  
  // Relationships
  practice   Practice @relation(fields: [practiceId], references: [id], onDelete: Cascade)
  pillar     Pillar   @relation(fields: [pillarId], references: [id], onDelete: Cascade)
  
  @@unique([practiceId, pillarId])
  @@index([practiceId], map: "idx_practice_pillars_practice")
  @@index([pillarId], map: "idx_practice_pillars_pillar")
  @@map("practice_pillars")
}

/// Event entity - immutable audit log for research data integrity
/// Isolation: team_id is the primary boundary for all queries
/// Privacy: Events contain system actions, not sensitive user data
model Event {
  /// Auto-incrementing event identifier
  id            BigInt   @id @default(autoincrement())
  
  /// Event classification (e.g., 'user.registered', 'issue.created')
  eventType     String   @map("event_type") @db.VarChar(50)
  
  /// User who triggered the event (NULL for system events)
  actorId       Int?     @map("actor_id")
  
  /// Team context for the event (NULL for user-level events)
  teamId        Int?     @map("team_id")
  
  /// Type of entity affected (e.g., 'user', 'issue', 'practice')
  entityType    String?  @map("entity_type") @db.VarChar(50)
  
  /// Identifier of the affected entity
  entityId      Int?     @map("entity_id")
  
  /// Action performed (e.g., 'created', 'updated', 'deleted')
  action        String?  @db.VarChar(50)
  
  /// JSON payload with event-specific data
  payload       Json?
  
  /// Schema version for payload structure evolution
  schemaVersion String   @default("v1") @map("schema_version") @db.VarChar(10)
  
  /// Event creation timestamp (immutable)
  createdAt     DateTime @default(now()) @map("created_at")
  
  @@index([teamId, eventType], map: "idx_events_team_type")
  @@index([entityType, entityId], map: "idx_events_entity")
  @@index([eventType], map: "idx_events_type")
  @@map("events")
}
